<html>
<head>
	<meta charset="UTF-8">
	<!-- <META HTTP-EQUIV="Pragma" CONTENT="no-cache"> -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Convert and view your UTM coordinates">
	<meta name="keywords" content="online,convert,conversion,UTM,Latitude/Longitude,latlon,lat,long,long,gps,map,location,coordinate,map coordinate">

	<link rel="shortcut icon" href="./img/favicon.png">
	<meta property="og:type" content="website"/>
	<meta property="og:title" content="Convert and view your UTM coordinates"/>
	<meta property="og:description" content="Enter UTM or latitude/lonigitude coordinates, in the format you like. View them formatted in the writing style you prefer, as well as on the map. Easily convert between UTM zones if you need to."/>
	<meta property="og:url" content="http://vafe.net/geo/"/>
	<meta property="og:image" content="http://vafe.net/geo/img/site-sample-2.jpg"/>
	<link rel="stylesheet" type="text/css" href="./css/geoparse.css">
	<script src="./js/geoclasses.js"></script>
	<script src="./js/geoconverter.js"></script>
	<script src="./js/geoparse.js"></script>
	<script src="./js/norgeskart.js"></script>
	<script src="./lib/jquery-1.11.1.js"></script>
	<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&libraries=geometry"></script>
	<script src="./lib/amplify.min.js"></script>
	<script src="./lib/markerwithlabel.js"></script>
	<title>Convert and view your GPS and UTM coordinates</title>
</head>
<body>
<div id="divAll">
	<div id="divPanel">
		<div id="divHeader"><span class="header">EARTH</span><br/><p style="font-size:0.7em;margin-top:0;">Convert between GPS and UTM coordinates</p></div>
		<div id="divInput">
			<iframe id="dummy_iframe" name="dummy_iframe" src="javascript:false" style="display: none;"></iframe> <!-- you'll want this hidden -->
			<form id="convertPos" name="convertPos" target="dummy_iframe">
			<div style="float:left;margin-right:5px;">
		    	  Enter coordinate: <input id="txtCoordinate" autofocus class="inputText" tabindex="1" >
			</div>
			<div style="float:left;">
				  <button id="btnConvertPos" type="submit" class="rounded-corners" onclick="onClickConvertPos()" tabindex="2">Convert</button>
			</div>
			<div id="divMyLocation" style="float:right">
					<div id="sMyLocation"></div>
					<button id="btnAddMyPos" class="rounded-corners"  onclick="onClickAddMyPos()" tabindex="3">My location</button>
			</div>
			</form>
			<div style="clear: both"></div>
		</div>
		<div id="divTable">
			 <table id="posTable">
			  		 <thead>
			  		 <!-- <tr><th>Label</th><th>Latitude / longitude <button class="rounded-corners" style="float:right">C</button></th><th>UTM <button class="rounded-corners" style="float:right">C</button></th></tr> -->
				  		 <tr>
				  		 	<th>&nbsp;</th>
				  		 	<th>Latitude / longitude</th>
				  		 	<th>UTM</th>
				  		 	<th>km</th>
				  		 	<th><img id="hiddenImgRemoveRow" style="visibility:hidden;"></th>
			  		 	</tr>
					 </thead>
					 <tbody>
					 </tbody>
					 <tfoot>
				  		 <tr>
						 	 <td></td>
							 <td>
							 	 <select id="optDegrees" class="rounded-corners" onchange="onClickFormatChange(this, 'degrees')" >
								 		 <option value="d">d°</option>
										 <option value="dm">d°m'</option>
										 <option value="dms">d°m's"</option>
								 </select>
								 <!-- ToDo: Ala http://proto.io/freebies/onoff/ -->
							 	 <div><input id="chkLatlonOrderNE" type="checkbox" onchange="onClickFormatChange(this, 'degOrder')" class="rounded-corners" value="posNE">N before E</div>
							 	 <div><input id="chkLatlonNeg" type="checkbox" onchange="onClickFormatChange(this, 'degNeg')" class="rounded-corners" value="posNE">Use negative for S and W</div>
							 </td>
							 <td>
								 <div>Fixed zone: <input size="2" onchange="onClickFormatChange(this, 'utmZone')" class="rounded-corners"></div>
								 <div><input id="chkUtmOrderEN" type="checkbox" onchange="onClickFormatChange(this, 'utmOrder')" class="rounded-corners" value="posEN">E before N</div>
								 <div><input id="chkUtmStrict" type="checkbox" onchange="onClickFormatChange(this, 'utmStrict')" class="rounded-corners" value="strict">Strict UTM</div>
							 </td>
							 <td colspan="2" style="text-align:center;">
							 	<button id="btnClear" class="rounded-corners" onclick="onClickClearLocations()" >Clear</button> 
							 </td>
						 </tr>
					 </tfoot>
				</table>
		 </div>
				
		<div id="divUsage">
			<p class="zoneReplacement" style="margin-bottom:0;font-size:0.7em;">
			The current version requires that you fill in the UTM grid zone (such as %gridZone%), and that you specify at the directions (NSEW) of the latitude/longitude.  Planning a solution where you don't need this... :)
			</p>
			<!--p style="margin-bottom:0;">
			Available on <a href="https://github.com/vbakke/geoparse">https://github.com/vbakke/geoparse</a>. 
			Please report bugs to: <a href="https://github.com/vbakke/geoparse/issues">GitHub Issues</a>, or send me an <a href="mailto:geoparse@vafe.net?subject=Geoparse%20bug">email</a> if you have comments on the <a href="https://github.com/vbakke/geoparse/blob/master/ToDo%20-%20GeoParse.txt">ToDo list</a>.
			</p>
			<p>
				Cheers, :)
			</p-->
		</div>
	</div>
	<div id="divMap">
		<div id="divMap2"></div>
		<div id="divMapHeader">
			<button id="btnOpenNorgeskart" onclick="onClickOpenNorgeskart()" class="rounded-corners" style="float:right">Norgeskart.no</button>
			<div class="mapOptions"><input id="chkMapEdit" type="checkbox" onchange="onClickMapEditChk(this)" class="rounded-corners" >Allow editing in map</div>
			<div class="mapOptions"><input id="chkDisplayLabels" type="checkbox" onchange="onClickDisplayLabelsChk(this)" class="rounded-corners" >Display labels in map</div>
			
			<div class="clearfix"></div>
		</div>
	</div>


<div style="clear: both"></div>
</div>
 
<script type="text/javascript">
	var posArray = [];
	var centerLocationIndex = null;
	var initZoomLevel = 2;
	var firstZoomLevel = 7;
	var latlonFormats = { d: "d°N", dm: "d° m'N", dms: "d° m' s\"N"};
	var config_default = {utm: {strict: false, orderEN: true, zone: null},
						 latlon: {format: "dms",  orderNE: true, useNeg: false},
						 map: {editInMap: false, displayLabalsInMap: true}};
	var config = amplify.store("config");
	var imgRemoveRow = "./img/red-x_16_gray.png";
	var imgRemoveRowHover = "./img/red-x_16.png";
	$("#hiddenImgRemoveRow").prop("src", imgRemoveRowHover);
	if (!config) {
		config = config_default;
		amplify.store("config", config);
	}
	updateTableOptions();
	updateMapOptions();

	var myLocation = undefined; // a geoLatLon object
	var markers;
	var map;
	var clickedMapPos, tmpMapZoom;
	var tb = $("#posTable tbody");
	var txtCoordinate = $("#txtCoordinate");

	function initialize() {
		initMap("divMap2");
		clearLocations();

		txtCoordinate.on("focus",function(e){
			if (this.selectionEnd == 0) {
    			$(this).select();
    			this.isEnterFocus = true;
			}
		});
		txtCoordinate.on("mouseup",function(e){
			if (this.isEnterFocus) {
				e.preventDefault();
				this.isEnterFocus = false;
			}
		});
	}
	function initMap(div) {
		updateMapOptions();
		var mapOptions = {
			zoom: initZoomLevel,
			center: new google.maps.LatLng(0, 0),
			scaleControl: true,
			mapTypeId: google.maps.MapTypeId.ROADMAP
		  };
		
		map = new google.maps.Map(document.getElementById(div), mapOptions);
		google.maps.event.addListener(map, 'click', function(event) {
			if (config.map.editInMap) {
				tmpMapZoom = map.getZoom();
				clickedMapPos = event.latLng;
				setTimeout("onClickInMap()", 600);
			}
        });

		// Get current location
		if (navigator.geolocation) {
			var span = $("#sMyLocation");
			navigator.geolocation.getCurrentPosition(function (location) {
				var lat = location.coords.latitude;
				var lon = location.coords.longitude;

				myLocation = new geoLatLon(lat, lon);

				map.setCenter(new google.maps.LatLng(lat, lon));
				map.setZoom(firstZoomLevel);
				// Display the location
				var tmp = myLocation.toString();
				span.innerText = tmp;

				var tmpUtm = geoconverter.LatLonToUTM(myLocation);
				var gridZone = tmpUtm.getGridZone() || "33W";
				$(".zoneReplacement").text(function(i, val) {
					return val.replace("%gridZone%", gridZone)
				});
			});
		} 

	}
	function onClickInMap() {	
		if(tmpMapZoom == map.getZoom()){
			var location = addLatLonLocation(clickedMapPos.lat(), clickedMapPos.lng(), undefined, true);
			clickedMapPos = null;

			var utmLogMsg = approxUtm(location.utm);
			ga('send', 'event', 'user-click', 'addMapPos', 'addMapPos-'+utmLogMsg); 
			ga('send', 'event', 'debug-click', 'addMapPos', 'addMapPos-'+location.utm.toString()); 
			ga('send', 'pageview', {
					'page': '/geoparse/addMyPos',
					'title': utmLogMsg
			});
		}
	}

	function onClickCellDistance(elem) {
		var tr = $(elem).closest("tr");
		var index = tr.index();
		if (index != centerLocationIndex) {
			centerLocationIndex = index;
			updateAllDistancesInTable(tb);
		}

	}

	function onClickTableCell(elem) {
		txtCoordinate.val($(elem).text());
		txtCoordinate.select();
	}

	function onClickLabelCell(elem) {
		var td = $(elem);
		var label = td.text();

		if (label) {
			var width = td.width();
			//var location = posArray[index];
			td.empty();
			td.append('<input id="txtLabel" autofocus class="inputText" style="width:'+(width+20)+'px">');
			var input = td.find("input");
			//input.focusout(onExitLabelEdit);
			input.blur(onExitLabelEdit);
			input.keyup(onKeyupInLabel);
			input.val(label);
			input.focus();
		}
	}
	
	function onKeyupInLabel(event) { 
		if (event.which == 13) {
			onExitLabelEdit(event);
		}  else if (event.which == 27) {
			escapeLabelFromInput( $(event.currentTarget) );
		} else {
			updateLabelFromInput( $(event.currentTarget) );
		}
			
	}
	
	function updateLabelFromInput(input, store) {
		var index = input.closest("tr").index();

		var label = input.val().trim();
		if (label == "")
			label = posArray[index].label;

		var location = posArray[index];
		location.marker.set("labelContent", label);
		if (store)
			location.label = label;

		return label;
	}

	function escapeLabelFromInput(input) {
		var index = input.closest("tr").index();

		var label = posArray[index].label;

		var location = posArray[index];
		location.marker.set("labelContent", label);

		var td = input.closest("td");
		td.empty();
		td.text(label);
	}

	function onExitLabelEdit(event) {
		var input = $(event.currentTarget);
		var label = updateLabelFromInput(input, true);
		var formattedLabel = '<span class="dotted hand">'+label+'</span>';
		
		var td = input.closest("td");
		td.empty();
		td.append(formattedLabel);
	}

	function onClickConvertPos() {
		var orgStr = txtCoordinate.val();
		ga('send', 'event', 'debug-click', 'dbg-convertPos', 'dbg-convertPos-'+orgStr); 
		ga('send', 'event', 'user-click', 'convertPos', 'convertPos-'+orgStr.replace(/[0-8]/g,'9'));
		ga('send', 'pageview', {
				'page': '/geoparse/convertPos',
				'title': orgStr.replace(/[0-8]/g,'9')
		});
		var attempts = geoparse.parse(orgStr);
		var latlon, utm;

		if (attempts.bestMatch == "latlon") {
			latlon = attempts.pos.latlon;
			utm = geoconverter.LatLonToUTM(latlon);
		}
		else if (attempts.bestMatch == "utm") {
			utm = attempts.pos.utm;
			latlon = geoconverter.UTMToLatLon(utm);
			// Convert back again to UTM to normalize according to config
			geoconverter.LatLonToUTM(latlon, utm); 
		}
		else {
			// Unknown format
		}

		if (latlon && utm) {
			addLocation(orgStr, latlon, utm);
		} else {
			// What to do
		}

		// Return false to avoid page reload
		return false;
	}

	
	function onClickOpenNorgeskart() {
		var viewport = {w: $(window).width(), h: $(window).height()};
		var url = norgeskart.makeUrl(posArray, viewport, config.map.displayLabalsInMap);
		ga('send', 'event', 'debug-click', 'openKart', 'openKart-'+url);
		ga('send', 'event', 'user-click', 'openKart', 'openKart');
		window.open(url);
	}
	
	function onClickMapEditChk(elem) {
		var checked = elem.checked;
		config.map.editInMap = checked;
		amplify.store('config', config);
		ga('send', 'event', 'user-click', 'changeMapConfig-EditInMap', 'changeMapConfig-EditInMap-'+checked); 

		for (var i=0; i<posArray.length; i++) {
			var location = posArray[i];
			var marker = location.marker;
			if (marker) {
				marker.set("draggable", checked);
			}
		}		
	}
	
	function onClickDisplayLabelsChk(elem) {
		var checked = elem.checked;
		config.map.displayLabalsInMap = elem.checked;
		amplify.store('config', config);
		ga('send', 'event', 'user-click', 'changeMapConfig-DisplayLabel', 'changeMapConfig-DisplayLabel-'+checked); 

		for (var i=0; i<posArray.length; i++) {
			var location = posArray[i];
			var marker = location.marker;
			if (marker) {
				marker.set("labelVisible", checked);
			}
		}
	}
	
	function onClickFormatChange(elem, type) {
		// Lat/Lon
		var vDbg;
		if (type=="degrees") {
			config.latlon.format = elem.value;
			vDbg = config.latlon.format;
		}
		if (type=="degOrder") {
			config.latlon.orderNE = elem.checked;
			vDbg = config.latlon.orderNE;
		}
		if (type=="degNeg") {
			config.latlon.useNeg = elem.checked;
			vDbg = config.latlon.useNeg;
		}
		// UTM
		if (type=="utmOrder") {
			config.utm.orderEN = elem.checked;
			vDbg = config.utm.orderEN;
		}
		if (type=="utmStrict") {
			config.utm.strict = elem.checked;
			vDbg = config.utm.strict;
		}
		if (type=="utmZone") {
			var orgZone = config.utm.zone;
			if (!elem.value || elem.value.trim() == "" || parseInt(elem.value)==NaN)
				config.utm.zone = null;
			else
				config.utm.zone = parseInt(elem.value);
			vDbg = config.utm.zone;
			if (orgZone != config.utm.zone)
				regenerateUtm(config.utm.zone);
		}

		amplify.store('config', config);

		ga('send', 'event', 'user-click', 'changeFormat-'+type, 'changeFormat-'+type+"-"+vDbg); 
		
		// Regenerate table
		generateTable();
	}
	
	function onClickClearLocations() {
		ga('send', 'event', 'user-click', 'clear', 'clear-'+posArray.length); 
		var btn = $("#btnAddMyPos");
		//btn.prop("disabled", false);
		clearLocations();
	}

	function onClickRemoveRow(elem) {
		var index = tb.index(elem.parentNode.parentNode);
		var tr = $(elem).closest("tr");
		var tdUtm = tr.find("td").eq(2);

		txtCoordinate.val(tdUtm.text());

		index = tr.index();
		removeLocation(index);

		ga('send', 'event', 'user-click', 'removeRow', 'removeRow-'+index); 
	}

	// Ask browser for location
	function onClickAddMyPos() {
		var span = $("#sMyLocation");
		span.innerHTML = "";
		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(addMyLocation);
		} else {
			span.innerHTML = "Geolocation is not supported by this browser.";
		}
	}
	function addMyLocation(pos) {
		if (pos == undefined) {
			var span = $("#sMyLocation");
			span.innerHTML = "Could not retrieve your location";
		} else {
			var me = $("#btnAddMyPos");
			//me.prop("disabled", true);

			var label = "Me";
			var location = addLatLonLocation(pos.coords.latitude, pos.coords.longitude, label);

			var utmLogMsg = approxUtm(location.utm);
			ga('send', 'event', 'user-click', 'addMyPos', 'addMyPos-'+utmLogMsg); 
			ga('send', 'event', 'debug-click', 'addMyPos', 'addMyPos-'+location.utm.toString());
			ga('send', 'pageview', {
					'page': '/geoparse/addMyPos',
					'title': utmLogMsg
			});
		}
	}
				
	function addLatLonLocation(lat, lon, label, freezeMap) {
		//var orgStr = location.coords.latitude + " N " + location.coords.longitude + " E ";
		var latlon = new geoLatLon(lat, lon);
		var utm = geoconverter.LatLonToUTM(latlon);
		var location = addLocation("", latlon, utm, label, freezeMap);
		return location;
	}

	function updateLatLonLocation(location, newLat, newLon) {
		//var orgStr = location.coords.latitude + " N " + location.coords.longitude + " E ";
		var latlon = new geoLatLon(newLat, newLon);
		var utm = geoconverter.LatLonToUTM(latlon);
		location.orgStr = "";
		location.latlon = latlon;
		location.utm = utm;
		updateLocationInTable(tb, location);
	}
	function getLabelLetter() {
		var labelLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		var label;

		if (posArray.length==0) {
			label = labelLetters[0];
		} else {	
			var usedLabels = "";
			for (var i=0; i<posArray.length; i++) {
				if (posArray[i].label && posArray[i].label.length == 1)
					usedLabels += posArray[i].label;
			}
			for (var i=0; i<labelLetters.length; i++) {
				if ( usedLabels.indexOf(labelLetters[i]) == -1) {
					label = labelLetters[i];
					break;
				}
			}
			if (!label)
				label = labelLetters[-1];
		}
		return label;

	}
	function addLocation(orgStr, latlon, utm, label, freezeMap) {
		if (!label) {
			label = getLabelLetter();
		}
		var location = {orgStr: orgStr, latlon: latlon, utm: utm, label: label};
		
		
		addLocationToTable(tb, location);
		addLocationToMap(location, freezeMap);

		
		posArray.push(location);
		
		return location;
	}
	function getDistance(locationA, locationB) {
		var latLngA = new google.maps.LatLng(locationA.latlon.lat, locationA.latlon.lon);
		var latLngB = new google.maps.LatLng(locationB.latlon.lat, locationB.latlon.lon);
		var dist = google.maps.geometry.spherical.computeDistanceBetween(latLngA, latLngB);
		return dist;
	}
	function addLocationToTable(tb, location) {
		if (posArray.length <= 0) {
			tb.empty();
			centerLocationIndex = 0;
		}

		var index = posArray.length;
		var dist = undefined;
		if (index != centerLocationIndex) {
			dist = getDistance(posArray[centerLocationIndex], location);
		}

		var str = generateTableRowStr(index, location, dist);
		tb.append("<tr>"+str+"</tr>");
	}
	function updateAllDistancesInTable(tb, exceptIndex) {
		for (var index=0; index<posArray.length; index++) {
			if (index != exceptIndex)
				updateLocationInTable(tb, posArray[index]);
		}
	}
	function updateLocationInTable(tb, location) {
		var index = posArray.indexOf(location);
		var tableRow = tb.find("tr")[index];

		var dist = undefined;
		if (index != centerLocationIndex) {
			dist = getDistance(posArray[centerLocationIndex], location);
		} else {
			updateAllDistancesInTable(tb, index);
		}

		var str = generateTableRowStr(index, location, dist);
		tableRow.innerHTML = str;
	}
	function generateTableRowStr(index, location, dist) {
		var labelStr = location.label;
		var format = latlonFormats[config.latlon.format];
		var latlonStr = location.latlon.toString(format, ' ', config.latlon.useNeg, config.latlon.orderNE);
		var utmStr = location.utm.toString(config.utm.strict, config.utm.orderEN, ' ');
		
		var distStr = (dist == undefined) ? "&nbsp;&bull;" : (dist/1000).toFixed(1);
		var distStyle = (dist == undefined) ? "" : 'class="hand dotted"';


		var str = "<td onclick=\"onClickLabelCell(this)\"><span class='hand dotted'>"+labelStr+"</span></td>" + 
					"<td onclick=\"onClickTableCell(this)\"><span class='hand dotted'>"+latlonStr+"</span></td>" +
					"<td onclick=\"onClickTableCell(this)\"><span class='hand dotted'>"+utmStr+"</span></td>" +
					"<td onclick=\"onClickCellDistance(this)\"><span "+distStyle+">"+distStr+"</span></td>" +
					'<td style="text-align:center;"><img class=\"hand\"  src="'+imgRemoveRow+'" hover-src="'+imgRemoveRowHover+'" onmouseover="imgSwap(this)" onmouseout="imgSwap(this)"   onclick="onClickRemoveRow(this)"></td>';
		return str;
	}
	
	
	function addLocationToMap(location, freezeMap) {
		if (map == undefined)
			initMap();

		if (freezeMap == undefined) freezeMap = false;
			
		// Make a bounding box of currently visible markers 
		var data, markerPos;
		var boundingbox = new google.maps.LatLngBounds();
		var bbCount = 0;
		for (var i=0; i<posArray.length; i++) {
			data = posArray[i];
			markerPos = new google.maps.LatLng(data.latlon.lat, data.latlon.lon);
			if (map.getBounds().contains(markerPos)) {
				boundingbox.extend(markerPos);
				bbCount++;
			}
		}
		
		// Add new marker to map
		var newLat = location.latlon.lat;
		var newLon = location.latlon.lon;
		markerPos = new google.maps.LatLng(newLat, newLon);
		var labelVisible = config.map.displayLabalsInMap;
		var markerOptions = {   map:map,
								draggable:config.map.editInMap,
								animation: google.maps.Animation.DROP,
								position: markerPos,
								locationObj: location,
								labelContent: location.label,
								labelAnchor: new google.maps.Point(-14, 40),
								labelClass: "markerlabel", // the CSS class for the label
								labelStyle: {opacity: 0.95},
								labelVisible: labelVisible
		};
		var marker = new MarkerWithLabel(markerOptions);
		google.maps.event.addListener(marker, 'drag', markerDrag);
		google.maps.event.addListener(marker,'dragend', markerDragEnd);
		location.marker = marker;
		boundingbox.extend(markerPos); // Always add new marker to bounding box
		bbCount++;
		
		// Resize and zoom to boundingbox
		if (!freezeMap) {
			if (bbCount == 1) {
				if (map.getZoom() < firstZoomLevel)
					map.setZoom(firstZoomLevel);
				if (!map.getBounds().contains(markerPos))
					map.setCenter(markerPos);
			} else {
				map.fitBounds(boundingbox);
			}
		}

	}
	function markerDragEnd(event) {
		var posStr = this.position.lat().toFixed(5)+"N "+this.position.lng().toFixed(5)+"E";
		ga('send', 'event', 'user-click', 'dragTo', 'dragTo-'+posStr); // .replace(/[0-8]/g,'9'));
		updateLatLonLocation(this.locationObj, this.position.lat(), this.position.lng());
	}
	function markerDrag(event) {
		updateLatLonLocation(this.locationObj, this.position.lat(), this.position.lng());
	}
	
	function clearLocations() {
		clearLocationsFromMap();
		clearLocationsFromTable();
		posArray = [];
	}
	
	function removeLocation(index) {
		removeLocationFromMap(index);
		removeLocationFromTable(index);
		posArray.splice(index, 1); // Remove the element
	}
	
	function clearLocationsFromMap() {
		for (var i=0; i<posArray.length; i++) {
			removeLocationFromMap(i);
		}
	}

	function removeLocationFromMap(index) {		
		var location = posArray[index];
		if (location.marker) {
			location.marker.locationObj = null;
			location.marker.setMap(null);
			location.marker = null;
		}
	}
	

	function clearLocationsFromTable() {
		tb.empty();
		addToTableNoElelemntsText();
	}

	function removeLocationFromTable(index) {
		if (index < centerLocationIndex)
			centerLocationIndex--;
		if (index == centerLocationIndex) {
			if (centerLocationIndex < posArray.length)
				centerLocationIndex++;
			updateAllDistancesInTable(tb, index);
			centerLocationIndex--;
		}

		if (posArray.length == 1)
			centerLocationIndex = undefined;

		var tr = tb.find("tr").eq(index);

		tr.remove();

		if (tb.children().length == 0)
			addToTableNoElelemntsText();
	}

	function addToTableNoElelemntsText() {
		tb.append("<tr><td></td><td><i>No coordinates added yet</td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td></td><td></td></tr>");
	}

	function regenerateUtm(zone) {
		for (var i=0; i<posArray.length; i++) {
			var location = posArray[i];
			var utmNew = geoconverter.LatLonToUTM(location.latlon, undefined, zone);
			location.utm = utmNew;
		}
	}

	function generateTable() {
		if (posArray.length > 0) {
			tb.empty();
			for (var i=0; i<posArray.length; i++) {
				addLocationToTable(tb, posArray[i]);
			}
		}
	}

	function updateTableOptions() {
		var s = '#optDegrees option[value='+config.latlon.format+']';
		var o = $(s);
		//o.prop('selected', true);
		$('#optDegrees option[value='+config.latlon.format+']').prop('selected', true);
		$("#chkLatlonNeg").attr("checked", config.latlon.useNeg);
		$("#chkLatlonOrderNE").attr("checked", config.latlon.orderNE);
		$("#chkUtmStrict").attr("checked", config.utm.strict);
		$("#chkUtmOrderEN").attr("checked", config.utm.orderEN);
	}

	function updateMapOptions() {
		$("#chkMapEdit").attr("checked", config.map.editInMap);
		$("#chkDisplayLabels").attr("checked", config.map.displayLabalsInMap);
	}


	function approxUtm(utm) {
		var round = 1000; //  in meters
		var str = utm.zone + utm.band + " " + Math.floor(utm.easting/round)*round + "E " + Math.floor(utm.northing/round)*round + "N";
		return str;
	}


	function imgSwap(elem) {
		$(elem).attr({
				'src':        $(elem).attr('hover-src'), 
				'hover-src':  $(elem).attr('src') 
		});
	}
	
	function copyToClipboard(b, str) {
		alert("Str: '"+str+"'");
		
		var clip = new ClipboardEvent( 'copy' );
		clip.clipboardData.setData( 'text/plain', str);
		clip.preventDefault();
		
		b.target.dispatchEvent( clip );
		
	}

	// Add on load event to initialize the whole shebang
	google.maps.event.addDomListener(window, 'load', initialize);
</script>
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	if (document.URL.indexOf("http://localhost") > -1)
		ga('create', 'UA-6677714-4', 'auto');   // development
	else
		ga('create', 'UA-6677714-3', 'auto');   // public site
	ga('require', 'displayfeatures');
	ga('set', 'appName', 'GeoParse');
	ga('send', 'pageview');
</script>	

</body>
</html>
